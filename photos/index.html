<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>Narun Raman</title>
  <meta name="description" content="Narun's photos">
  <meta name="author" content="Narun Raman">

  <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/computer-modern@0.1.2/cmu-bright.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/computer-modern@0.1.2/cmu-serif.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/custom.css">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/0504-31.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/0504-31.png">
  <link rel="shortcut icon" href="/assets/images/0504-31.png">

  <style>
    :root { --gap: 2px; }
    *, *::before, *::after { box-sizing: border-box; }

    /* Make navbar brand smaller for this page */
    .navbar-brand { font-size: 1rem !important; }

    /* Reduce spacing between navbar and horizontal line */
    .container.mt-5 { margin-top: 1rem !important; }

    hr { margin-top: 0.5rem; margin-bottom: 1rem; }

    /* Full-page splash photo */
    .splash-container {
      position: relative;
      height: calc(100vh - 60px);
      width: 100%;
      overflow: hidden;
      margin-top: 0;
    }
    .splash-photo { width: 100%; height: 100%; object-fit: cover; object-position: center; }
    .splash-container::after {
      content: ""; position: absolute; top: 0; left: 0; right: 0; height: 150px;
      background: linear-gradient(to bottom, white, transparent); pointer-events: none; z-index: 1;
    }
    .splash-container::before {
      content: ""; position: absolute; bottom: 0; left: 0; right: 0; height: 210px;
      background: linear-gradient(to top, black, transparent); pointer-events: none; z-index: 1;
    }
    .splash-overlay {
      position: absolute; bottom: 0; left: 0; right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.7));
      color: white; padding: 2rem; text-align: center;
    }
    .splash-overlay h1 { font-size: 2.5rem; margin-bottom: 1rem; color: white; }

    @media (max-width: 768px) {
      .splash-container { height: calc(100vh - 50px); }
      .splash-overlay h1 { font-size: 2rem; }
      .splash-overlay { padding: 1.5rem; }
    }

    /* Black gallery section */
    .gallery-section {
      background-color: black;
      min-height: 100vh;
      padding: 1rem 0;
      color: white;
      overflow-x: hidden; /* Prevent horizontal scroll */
    }

    .gallery-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 2rem;
      display: flex;
      flex-direction: column;
      gap: 2rem;
      position: relative;
    }

    .gallery-content { flex: 1; overflow: visible; }

    .gallery-selector { width: 100%; text-align: center; padding: 1rem 0; }
    .gallery-selector h3 { color: white; margin-bottom: 1rem; font-size: 1.2rem; }

    .gallery-options { display: flex; justify-content: flex-end; flex-wrap: wrap; gap: 2rem; }
    .gallery-option {
      color: white !important; text-decoration: none !important; font-size: 1rem;
      transition: all 0.3s ease; cursor: pointer; position: relative;
    }
    .gallery-option:hover { color: #dc3545 !important; text-decoration: none !important; }
    .gallery-option.active { color: #dc3545 !important; text-decoration: none !important; }
    .gallery-option.active:hover { color: #dc3545 !important; text-decoration: none !important; }
    .gallery-option.active::after {
      content: ""; position: absolute; bottom: -5px; left: 0; right: 0; height: 2px; background: #dc3545;
    }

    @media (max-width: 768px) {
      .gallery-container { padding: 0 1rem; }
      .gallery-options { gap: 1rem; }
      .gallery-option { font-size: 0.9rem; }
    }
    
    /* === Justified grid (MVP integrated) === */
    .photo-grid {
      width: 100vw;
      margin-left: calc(-50vw + 50%); /* full-bleed centering */
      display: flex;           /* stack rows vertically */
      flex-direction: column;
      row-gap: var(--gap);     /* thin, uniform gap BETWEEN rows */
      line-height: 0;
      font-size: 0;
      padding: 0;
      margin-top: 0 !important;
    }

    .photo-row {
      display: flex;
      gap: var(--gap);         /* thin, uniform gap WITHIN the row */
      align-items: stretch;
      flex-wrap: nowrap;       /* never wrap within a row */
      margin: 0; padding: 0;
    }

    /* IMPORTANT: remove margin-stacking approach; gaps are controlled above */
    /* .photo-row + .photo-row { margin-top: 2px; }  <-- deleted on purpose */

    .photo-item { position: relative; overflow: hidden; flex: 0 0 auto; margin: 0; padding: 0; }
    .photo-item img { display: block; width: 100%; height: 100%; object-fit: cover; }

    /* Remove old responsive fixed heights; JS controls heights precisely */
    /* @media (max-width: 768px) { .photo-item { height: 30vw; } }
       @media (max-width: 480px) { .photo-item { height: 35vw; } } */

    #content .photo-grid img,
    #content .photo-row img,
    #content .photo-item img {
    margin: 0 !important;            /* kills the 1rem auto from custom.css */
    display: block;                   /* keep it block to avoid inline gaps */
    }

    /* Ensure rows control spacing, not margins */
    #content .photo-row {
    margin: 0 !important;
    padding: 0 !important;
    gap: 2px !important;              /* thin horizontal gutter */
    }

    /* Same thin vertical gutter between rows */
    #content .photo-grid {
    row-gap: 2px !important;
    line-height: 0;
    font-size: 0;
    }

    /* Hover dim + pointer */
    .photo-item { cursor: pointer; }
    .photo-item img { transition: filter 150ms ease; }
    .photo-item:hover img { filter: brightness(0.75); }

    /* Lightbox/Carousel */
    body.modal-open { overflow: hidden; }
    .lightbox { position: fixed; inset: 0; background: rgba(0,0,0,0.92); display: none; align-items: center; justify-content: center; z-index: 10000; }
    .lightbox.open { display: flex; }
    .lightbox-content { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; padding: 4rem 5rem; z-index: 1; }
    .lightbox-img { max-width: 100%; max-height: 100%; object-fit: contain; box-shadow: 0 0 30px rgba(0,0,0,0.35); }
    .lightbox-close, .lightbox-prev, .lightbox-next {
      position: absolute; background: rgba(0,0,0,0.55); border: none; color: #fff;
      width: 44px; height: 44px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center;
      font-size: 24px; line-height: 1; transition: background 120ms ease;
      z-index: 3; /* Ensure controls are above content */
      pointer-events: auto;
    }
    .lightbox-close:hover, .lightbox-prev:hover, .lightbox-next:hover { background: rgba(0,0,0,0.8); }
    .lightbox-close { top: 16px; right: 16px; }
    .lightbox-prev { left: 16px; top: 50%; transform: translateY(-50%); }
    .lightbox-next { right: 16px; top: 50%; transform: translateY(-50%); }

    @media (max-width: 768px) {
      .lightbox-content { padding: 3rem 3.5rem; }
      .lightbox-prev, .lightbox-next { width: 38px; height: 38px; }
    }
  </style>
</head>

<body>
  <div class="container mt-5">
    <nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0">
      <a class="navbar-brand mx-0 mr-sm-auto" href="/" title="Narun Raman">Narun Raman</a>
      <div class="navbar-nav flex-row flex-wrap justify-content-center">
        <a class="nav-item nav-link" href="/posts" title="Posts">Posts</a>
        <span class="nav-item navbar-text mx-1">/</span>
        <a class="nav-item nav-link" href="/photos" title="Photos">Photos</a>
        <span class="nav-item navbar-text mx-1">/</span>
        <a class="nav-item nav-link" href="/recs" title="Recs">Recs</a>
      </div>
    </nav>
  </div>

  <div id="content">
    <div class="splash-container">
      <img src="/assets/photos/wide_splash_photo.jpg" alt="Photo Gallery" class="splash-photo">
    </div>

    <div class="gallery-section">
      <div class="gallery-container">
        <div class="gallery-selector">
          <div class="gallery-options">
            <a href="#" class="gallery-option active" data-gallery="color">Color</a>
            <a href="#" class="gallery-option" data-gallery="bw">Black & White</a>
          </div>
        </div>

        <div class="gallery-content">
          <div id="gallery-display">
            <div class="photo-grid" id="photo-grid"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="footer" class="mb-5">
    <hr>
    <div class="container text-center">
    <a href="https://www.instagram.com/narun_pics/?hl=en" class="fab fa-instagram fa-1x" title="instagram"></a>
    </div>
    <div class="container text-center">
      <small>By Narun Raman</small>
    </div>
  </div>

  <!-- Lightbox / Carousel -->
  <div id="lightbox" class="lightbox" aria-hidden="true">
    <button class="lightbox-close" aria-label="Close">&times;</button>
    <button class="lightbox-prev" aria-label="Previous">&#10094;</button>
    <div class="lightbox-content">
      <img class="lightbox-img" alt="Expanded photo">
    </div>
    <button class="lightbox-next" aria-label="Next">&#10095;</button>
  </div>

  <script>
    
  const galleries = { color: 59, bw: 23};

  // Add base for asset paths so it works on file:// and GitHub Pages
  const ASSETS_BASE = '/assets/photos';
  const IS_FILE = typeof location !== 'undefined' && location.protocol === 'file:';

  // ==== PERF KNOBS ====
  const GAP = 2;
  const MIN_ROW_H = 140, MAX_ROW_H = 380, STEP_H = 8, LAST_ROW_MIN_FILL = 0.65;
  // User-tunable max row height. Change DEFAULT_USER_MAX_ROW_H here or set window.PHOTO_MAX_ROW_H before DOMContentLoaded.
  const DEFAULT_USER_MAX_ROW_H = 140;
  function effectiveMaxRowH() { return Math.min(MAX_ROW_H, window.PHOTO_MAX_ROW_H || DEFAULT_USER_MAX_ROW_H); }
    
  // Cache aspect ratios by src so tab switches are instant after first view
  const arCache = new Map(); // src -> number

  // Manifest of photos (loaded at runtime). GH Pages cannot list directories, so we use a JSON index.
  let PHOTO_INDEX = null;
  async function ensurePhotoIndex() {
    if (PHOTO_INDEX) return PHOTO_INDEX;
    // Firefox blocks fetch() on file://. In file mode, skip fetch and use fallback filenames.
    if (IS_FILE) { PHOTO_INDEX = {}; return PHOTO_INDEX; }
    try {
      const res = await fetch(`${ASSETS_BASE}/photo-index.json`, { cache: 'no-store' });
      if (res.ok) {
        PHOTO_INDEX = await res.json();
      } else {
        console.warn('photo-index.json not found or not ok:', res.status);
        PHOTO_INDEX = {};
      }
    } catch (e) {
      console.warn('Failed to load photo-index.json', e);
      PHOTO_INDEX = {};
    }
    return PHOTO_INDEX;
  }

  function gridWidthPx(el) {
    try {
      let w = el?.clientWidth || el?.getBoundingClientRect?.().width || 0;
      if (!w || w <= 0) {
        const p = el?.parentElement;
        w = p?.clientWidth || p?.getBoundingClientRect?.().width || 0;
      }
      if (!w || w <= 0) {
        w = (typeof window !== 'undefined' && window.innerWidth) ? window.innerWidth : 0;
      }
      w = Math.max(1, Math.floor(w || 0));
      return w;
    } catch (e) {
      console.warn('gridWidthPx failed; using viewport width', e);
      return Math.max(1, Math.floor((typeof window !== 'undefined' ? window.innerWidth : 1024)));
    }
  }

  function sourcesFromIndex(indexObj, galleryType) {
    const list = indexObj?.[galleryType];
    if (Array.isArray(list) && list.length) {
      return list.map(name => `${ASSETS_BASE}/${galleryType}/${name}`);
    }
    return [];
  }

  function fallbackSequentialSources(galleryType) {
    const n = galleries[galleryType] || 0;
    return Array.from({ length: n }, (_, i) => `${ASSETS_BASE}/${galleryType}/photo${i + 1}.jpg`);
  }

  async function sourcesFor(galleryType) {
    const indexObj = await ensurePhotoIndex();
    const fromIndex = sourcesFromIndex(indexObj, galleryType);
    return fromIndex.length ? fromIndex : fallbackSequentialSources(galleryType);
  }

  function toThumb(src) {
    // Insert "/thumbs" after the gallery folder: assets/photos/<gallery>/thumbs/<file>
    try { return src.replace(/(photos\/[^/]+)\//, '$1/thumbs/').replace(/\.jpg$/, '.webp'); } catch { return src; }
  }

  // NEW: Preload full-size images just for aspect ratio (Firefox-safe)
  async function preloadAspectRatios(srcs) {
    const missing = srcs.filter(s => !arCache.has(s));
    if (!missing.length) return;
    await Promise.allSettled(missing.map(src => {
      return new Promise(res => {
        const im = new Image();
        im.decoding = 'async';
        im.loading = 'eager';
        im.src = src; // full-size
        const done = () => {
          if (im.naturalWidth > 0 && im.naturalHeight > 0) {
            const ar = im.naturalWidth / im.naturalHeight;
            if (isFinite(ar) && ar > 0) arCache.set(src, ar);
          }
          res();
        };
        im.addEventListener('load', done, { once: true });
        im.addEventListener('error', done, { once: true });
        // Fallback timeout (in case neither event fires promptly)
        setTimeout(done, 1500);
      });
    }));
  }

  async function createPhotoGrid(galleryType) {
    const photoGrid = document.getElementById('photo-grid');
    const srcs = await sourcesFor(galleryType);

    // Preload ARs from full-size images first (this is the critical fix for Firefox uniform widths)
    await preloadAspectRatios(srcs);

    // Build photo objects with ARs (may still be missing for some; we will compute lazily on thumb load)
    const photos = srcs.map((src, i) => {
      const item = document.createElement('div');
      item.className = 'photo-item';
      const img = document.createElement('img');
      const thumb = toThumb(src);
      img.src = thumb; img.alt = '';
      img.loading = 'lazy'; img.decoding = 'async';
      img.setAttribute('fetchpriority', 'low');
      img.dataset.fullsrc = src;
      img.addEventListener('error', () => { if (img.src !== src) img.src = src; }, { once: true });
      item.appendChild(img);
      item.addEventListener('click', () => openLightbox(i, srcs));
      const ar = arCache.get(src) || null;
      if (ar) item.style.setProperty('--ar', ar);
      return { item, img, ar, full: src };
    });

    photoGrid.innerHTML = '';

    // Layout with whatever ARs we have (should be most/all after preload)
    const haveAll = photos.every(p => typeof p.ar === 'number');
    if (haveAll) {
      fastLayout(photoGrid, photos);
    } else {
      // Compute missing ARs from thumb load events (fallback path)
      let pending = photos.filter(p => !p.ar).length;
      const tryLayout = () => {
        fastLayout(photoGrid, photos.filter(p => typeof p.ar === 'number'));
      };
      photos.forEach(p => {
        if (p.ar) return;
        const finalize = () => {
          if (!p.ar && p.img.naturalWidth > 0) {
            p.ar = p.img.naturalWidth / p.img.naturalHeight;
            if (isFinite(p.ar) && p.ar > 0) arCache.set(p.full, p.ar);
          }
          pending--;
          if (pending <= 0) tryLayout();
        };
        p.img.addEventListener('load', finalize, { once: true });
        p.img.addEventListener('error', finalize, { once: true });
      });
      // Initial layout with known subset (avoid blank)
      tryLayout();
      // Safety: force layout after timeout even if some never load
      setTimeout(() => { tryLayout(); }, 1600);
    }
  }

  function fastLayout(container, photos) {
    const W = gridWidthPx(container);
    if (W <= 0 || photos.length === 0) return;

    // Use cached ARs to pick h immediately
    const ars = photos.map(p => p.ar);
    const best = pickOptimalTargetHeight(ars, W);
    renderJustified(container, photos, W, best.h, false);
  }

  function pickOptimalTargetHeight(ars, W) {
    let best = { h: MIN_ROW_H, bad: Infinity };
    const maxH = effectiveMaxRowH();
    for (let h = MIN_ROW_H; h <= maxH; h += STEP_H) {
      const rows = simulateRows(ars, W, h);
      const last = rows[rows.length - 1];
      const lastWidth = last.sumAR * h + GAP * Math.max(0, last.len - 1);
      const fill = Math.min(lastWidth / W, 1);
      let bad = (1 - fill) ** 2;
      if (fill < LAST_ROW_MIN_FILL) bad += 0.15 * (LAST_ROW_MIN_FILL - fill) ** 2;
      bad += 0.00002 * (h - 260) ** 2;
      if (bad < best.bad) best = { h, bad };
    }
    return best;
  }

  function simulateRows(ars, W, h) {
    const rows = [];
    let start = 0, sumAR = 0, len = 0;
    for (let i = 0; i < ars.length; i++) {
      const nextSum = sumAR + ars[i];
      const nextLen = len + 1;
      const nextWidth = nextSum * h + GAP * Math.max(0, nextLen - 1);
      if (nextWidth > W && len > 0) {
        rows.push({ start, end: i - 1, sumAR, len });
        start = i; sumAR = ars[i]; len = 1;
      } else { sumAR = nextSum; len = nextLen; }
    }
    rows.push({ start, end: ars.length - 1, sumAR, len });
    return rows;
  }

  function renderJustified(containerEl, photos, W, targetH, fillLastRow) {
    const frag = document.createDocumentFragment();
    containerEl.style.rowGap = GAP + 'px';

    const ars = photos.map(p => p.ar);
    const rows = simulateRows(ars, W, targetH);

    rows.forEach((row, idx) => {
      const isLast = idx === rows.length - 1;
      const rowDiv = document.createElement('div');
      rowDiv.className = 'photo-row';
      rowDiv.style.gap = GAP + 'px';
      rowDiv.style.contentVisibility = 'auto';
      rowDiv.style.containIntrinsicSize = '1px 260px';

      const gaps = GAP * Math.max(0, row.len - 1);
      // Height we will use for this row
      let h = (!isLast || fillLastRow)
        ? (W - gaps) / row.sumAR  // justified row fills width
        : targetH;                // ragged last row uses target height approximation

      const rowItems = photos.slice(row.start, row.end + 1);

      let widths = [];
      if (!isLast || fillLastRow) {
        // Justify: compute ideal raw widths and distribute rounding delta across ALL items
        const raw = rowItems.map(p => p.ar * h);
        widths = raw.map(r => Math.round(r));
        let total = widths.reduce((a,b) => a + b, 0) + gaps;
        let delta = W - total; // pixels to add (positive) or remove (negative) including gaps
        if (delta !== 0) {
          // Work only on image widths (exclude gaps) so adjust comparing sum(widths)+gaps
          // Build list with fractional parts for fair distribution
          const frac = raw.map((r,i) => ({ i, frac: r - Math.floor(r) }));
          frac.sort((a,b) => delta > 0 ? (b.frac - a.frac) : (a.frac - b.frac));
          let j = 0;
          while (delta !== 0 && j < frac.length * 4) { // guard loop
            const idxAdj = frac[j % frac.length].i;
            const adjust = delta > 0 ? 1 : -1;
            widths[idxAdj] += adjust;
            delta -= adjust;
            j++;
          }
          // Final safety: if still off due to rounding extremes, push remainder into last item
          if (delta !== 0) widths[widths.length - 1] += delta;
        }
      } else {
        // Ragged last row: no justification, preserve aspect ratios
        widths = rowItems.map(p => Math.round(p.ar * h));
      }

      rowItems.forEach((p, j) => {
        const w = Math.max(1, widths[j]);
        p.item.style.width  = w + 'px';
        p.item.style.height = Math.round(h) + 'px';
        rowDiv.appendChild(p.item);
      });

      frag.appendChild(rowDiv);
    });

    containerEl.innerHTML = '';
    containerEl.appendChild(frag);
  }

  function switchGallery(galleryType) {
    document.querySelectorAll('.gallery-option').forEach(o => o.classList.remove('active'));
    document.querySelector(`[data-gallery="${galleryType}"]`).classList.add('active');
    createPhotoGrid(galleryType);
  }

  // Lightbox state
  let LB_SOURCES = [];
  let LB_INDEX = 0;
  let LB_EL, LB_IMG, LB_BTN_PREV, LB_BTN_NEXT, LB_BTN_CLOSE;

  function openLightbox(startIndex, sources) {
    if (!sources || !sources.length) return;
    LB_SOURCES = sources;
    LB_INDEX = Math.max(0, Math.min(startIndex, sources.length - 1));
    if (!LB_EL) return;
    updateLightboxImage();
    document.body.classList.add('modal-open');
    LB_EL.classList.add('open');
    LB_EL.setAttribute('aria-hidden', 'false');
    document.addEventListener('keydown', onLightboxKey);
  }

  function closeLightbox() {
    if (!LB_EL) return;
    LB_EL.classList.remove('open');
    LB_EL.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('modal-open');
    document.removeEventListener('keydown', onLightboxKey);
  }

  function onLightboxKey(e) {
    if (e.key === 'Escape') closeLightbox();
    else if (e.key === 'ArrowRight') nextImage();
    else if (e.key === 'ArrowLeft') prevImage();
  }

  function nextImage() {
    if (!LB_SOURCES.length) return;
    LB_INDEX = (LB_INDEX + 1) % LB_SOURCES.length;
    updateLightboxImage();
  }

  function prevImage() {
    if (!LB_SOURCES.length) return;
    LB_INDEX = (LB_INDEX - 1 + LB_SOURCES.length) % LB_SOURCES.length;
    updateLightboxImage();
  }

  function updateLightboxImage() {
    if (!LB_IMG) return;
    LB_IMG.setAttribute('fetchpriority', 'high');
    LB_IMG.src = LB_SOURCES[LB_INDEX];
    preloadNeighborImages();
  }

  function preloadNeighborImages() {
    if (!LB_SOURCES || !LB_SOURCES.length) return;
    const next = LB_SOURCES[(LB_INDEX + 1) % LB_SOURCES.length];
    const prev = LB_SOURCES[(LB_INDEX - 1 + LB_SOURCES.length) % LB_SOURCES.length];
    [next, prev].forEach(src => { const im = new Image(); im.decoding = 'async'; im.loading = 'eager'; im.src = src; });
  }

  document.addEventListener('DOMContentLoaded', () => {
    // Lightbox element refs + events
    LB_EL = document.getElementById('lightbox');
    if (LB_EL) {
      LB_IMG = LB_EL.querySelector('.lightbox-img');
      LB_BTN_PREV = LB_EL.querySelector('.lightbox-prev');
      LB_BTN_NEXT = LB_EL.querySelector('.lightbox-next');
      LB_BTN_CLOSE = LB_EL.querySelector('.lightbox-close');

      LB_BTN_PREV && LB_BTN_PREV.addEventListener('click', prevImage);
      LB_BTN_NEXT && LB_BTN_NEXT.addEventListener('click', nextImage);
      LB_BTN_CLOSE && LB_BTN_CLOSE.addEventListener('click', closeLightbox);
      // Click outside image closes
      LB_EL.addEventListener('click', (e) => { if (e.target === LB_EL) closeLightbox(); });
      // Basic swipe
      let startX = 0;
      LB_EL.addEventListener('touchstart', e => { startX = (e.changedTouches?.[0]?.clientX) || 0; }, { passive: true });
      LB_EL.addEventListener('touchend', e => {
        const dx = ((e.changedTouches?.[0]?.clientX) || 0) - startX;
        if (Math.abs(dx) > 40) { if (dx < 0) nextImage(); else prevImage(); }
      }, { passive: true });
    }

    // Initial gallery + tab switching
    try { createPhotoGrid('color'); } catch (e) { console.error('createPhotoGrid failed', e); }
    document.querySelectorAll('.gallery-option').forEach(option => {
      option.addEventListener('click', e => {
        e.preventDefault();
        switchGallery(option.getAttribute('data-gallery'));
      });
    });

    let t; window.addEventListener('resize', () => {
      clearTimeout(t);
      t = setTimeout(() => {
        const active = document.querySelector('.gallery-option.active').getAttribute('data-gallery');
        createPhotoGrid(active);
      }, 120);
    });
  });
  </script>

</body>
</html>
